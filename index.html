<!DOCTYPE HTML>
<!DOCTYPE html>
<html>
<head>
    <meta charset = "UTF-8"/>
    <title>Test</title>
    <script src = "js/phaser.js"></script>
    <script src = "js/Boot.js"></script>
    <script src = "js/Preload.js"></script>
    <script src = "js/Level1.js>"></script>
    <script src = "js/MainMenu.js"></script>
</head>


<body>
    <script type="text/javascript">
window.onload = function(){

    var game = new Phaser.Game(800,600,Phaser.CANVAS,'');

        game.state.add('Boot',Game.Boot);
        game.state.add('Preload',Game.Preload);
        game.state.add('MainMenu',Game.MainMenu);
        game.state.add('FailState',Game.FailState);
        game.state.add('Level1',Game.Level1);
        game.state.add('Level2',Game.Level2);

        game.state.start('Boot');

}


var Game = {};

Game.Boot = function(){};

//Loading the loading screen

Game.Boot.prototype = {

    init: function() {
        this.input.maxPointers = 1;

        this.stage.disableVisibilityChange = true;
    },

    //Assets we need for the loading screen
    preload: function() {
        this.load.image('logo', 'assets/diamond.png');
        this.load.image('preloader', 'assets/redblock.png');
    },

    create: function() {
        //Pass the torch to preload
        this.state.start('Preload');
    }
};

Game.Preload = function(){
    this.preloadBar = null;
};

Game.Preload.prototype = {
    preload: function() {
        //Logo rendering
        //this.splash = this.add.sprite(this.game.world.centerX, this.game.world.centerY, 'logo');
        //this.splash.anchor.setTo(0.5);

        //Preload bar rendering
        this.preloadBar = this.add.sprite(this.world.centerX, this.world.centerY + 25, 'preloader');
        this.preloadBar.anchor.setTo(0.5);
        this.time.advancedTiming = true;
        this.load.setPreloadSprite(this.preloadBar);

        //Asset loading
        this.load.tilemap('map', 'assets/maps/level1.csv');
        this.load.image('tileset', 'assets/brownblock.png');
        this.load.image('player', 'assets/blackblock.png');
        this.load.spritesheet('buttons', 'assets/start_button.png', 193, 71);
        this.load.image('EnemyRed', 'assets/redblock.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.audio('shoot','assets/shoot.wav');
        this.load.audio('thud','assets/thud.wav');
    },

    create: function() {
        //Pass the torch to Level1
        this.game.state.start('MainMenu');
    }
};



//ACTUAL MENU BELOW



Game.MainMenu = function(){};

var button;

Game.MainMenu.prototype = {
    create: function() {

        startButton = this.add.button(this.world.centerX -95, this.world.centerY + 200, 'buttons', 
                                  function(){
                                    this.game.state.start('Level1');
                                  },this,2,1,0);
        console.log("huh");

    }
}

//LEVEL 1 BELOW

//Defining enemy red
EnemyRed = function(index, game, x, y){

    this.red = game.add.sprite(x,y,'EnemyRed');
    this.red.anchor.setTo(0.5,0.5);
    this.red.name = index.toString();
    game.physics.enable(this.red,Phaser.Physics.ARCADE);
    this.red.body.immovable = true;
    this.red.body.collideWorldBounds = true;
    this.red.body.allowGravity = false;



    //this.redTween = game.add.tween(this.red).to({
    //    y: 250,
    //}, 2000, 'Linear', true, 0, 250, true);

}

var enemy1; 

Game.Level1 = function(){};

var map;
var layer;

var player;
var controls = {};
var playerSpeed = 325; 
var jumpTimer = 0;
var shootTime = 90;
var bullets;
var remaining = 2;
var chillTime = 200;
var chillTimeBad = 200;
var enemy1;
var enemy2;
var enemySpeed = 75;

///var button;

Game.Level1.prototype = {

    create: function(game) {
        //Background color definition
        this.stage.backgroundColor = '#d3d3d3';

        //Map initialization
        map = this.add.tilemap('map', 25, 25)
        map.addTilesetImage('tileset');
        layer = map.createLayer(0);
        layer.resizeWorld();
        remaining = 2;

        //Collision/Physics 
        this.physics.arcade.gravity.y = 1400;
        map.setCollisionBetween(0,0);
        //map.setTileIndexCallback(2,this.resetPlayer,this);

        //Set player
        player = this.add.sprite(100,300, 'player');
        player.anchor.setTo(0.5);
        //player.animations.add('runRight',[6, 7, 8, 9], 5, true);
        //player.animations.add('runLeft',[0, 1, 2, 3], 5, true);
        this.physics.arcade.enable(player);
        this.camera.follow(player);
        player.body.collideWorldBounds = true;
        game.physics.enable(player,Phaser.Physics.ARCADE);
        player.physicsBodyType = Phaser.Physics.ARCADE;
        player.body.velocity.x = 0;
        player.body.velocity.y = 0;

        //Set controls
        controls = {
            right: this.input.keyboard.addKey(Phaser.Keyboard.A),
            left: this.input.keyboard.addKey(Phaser.Keyboard.D),
            up: this.input.keyboard.addKey(Phaser.Keyboard.W),
            down: this.input.keyboard.addKey(Phaser.Keyboard.S),
            shoot: this.input.keyboard.addKey(Phaser.Keyboard.F),
        }

        //button = this.add.button(this.world.centerX - 95, this.world.centerY + 200, 
        //                      'buttons', function(){
        //                          console.log("ay");
        //                      },this,2,1,0);

        
        //Spawning bird
        enemy1 = new EnemyRed(0, game, player.x+400, player.y-200);
        enemy1.hp = 5;
        enemy2 = new EnemyRed(0, game, 100, enemy1.y+400);

        //Init bullets
        bullets = game.add.group();
        bullets.enableBody = true;
        bullets.physicsBodyType = Phaser.Physics.ARCADE;
        bullets.createMultiple(50, 'bullet');
        bullets.setAll('anchor.x',0.5);
        bullets.setAll('anchor.y',0.5);
        bullets.setAll('outOfBoundsKill', true);
        bullets.setAll('checkWorldBounds', true);
        bullets.setAll('allowGravity', false);


    },
    update: function(game) {
        //Collision
        this.physics.arcade.collide(player,layer,function(){
            if(game.time.now > chillTime){
                game.add.audio('thud').play();
                chillTime = game.time.now + 200;
            }
        });
        this.physics.arcade.collide(enemy1.red,layer);
        this.physics.arcade.collide(player,enemy1.red, function(){
            game.state.start('FailState');
        });
        this.physics.arcade.collide(player,enemy2.red, function(){
            game.state.start('FailState');
        });
        this.physics.arcade.collide(bullets,enemy1.red, function(){
            enemy1.hp -= 1;
            game.add.audio('shoot').play();
            bullets.getFurthestFrom(player).kill();
            if(enemy1.seen!=1){
                enemy1.seen = 1;
            }
        });
        this.physics.arcade.collide(bullets,enemy2.red, function(){
            enemy2.red.kill();
            remaining -= 1;
            game.add.audio('shoot').play();
            bullets.getFurthestFrom(player).kill();
        });
        this.physics.arcade.collide(bullets,layer, function(){
            bullets.getFurthestFrom(player).kill();
        });

        //Player movement
        player.body.velocity.x = 0.8*player.body.velocity.x;
        player.body.velocity.y = 0.8*player.body.velocity.y;
        if(Math.abs(player.body.velocity.x) >= playerSpeed*2){
            player.body.velocity.x = playerSpeed*2*(player.body.velocity.x/Math.abs(player.body.velocity.x));
        }
        if(Math.abs(player.body.velocity.y) >= playerSpeed*2){
            player.body.velocity.y = playerSpeed*2*(player.body.velocity.y/Math.abs(player.body.velocity.y));
        }
        player.body.allowGravity = false;
        player.body.bounce.set(0.8)


        if(controls.right.isDown){
        //  player.animations.play('runRight');
            player.body.velocity.x -= playerSpeed;
        }

        if(controls.left.isDown){
        //  player.animations.play('runLeft');
            player.body.velocity.x += playerSpeed;
        }

        if(controls.up.isDown){
            player.body.velocity.y -= playerSpeed;
        }

        if(controls.down.isDown){
            player.body.velocity.y += playerSpeed;
        }

        if(game.input.activePointer.isDown){
            shootbullet(game);
        }

        //State checks
        if(remaining==0){
            this.game.state.start('Level2');
        }

        if(enemy1.hp<=0){
            enemy1.red.kill();
            remaining -= 1;
        }

        //Enemy movement
        //radians1 = game.physics.arcade.angleBetweenCenters(enemy1, player);
        //game.physics.arcade.velocityFromRotation(radians1, 200, enemy1.red.body.velocity);
        distance1_from_player = Math.sqrt(Math.abs((player.x - enemy1.red.x))+Math.abs((player.y - enemy1.red.y)));
        if(distance1_from_player<=18){
            enemyMovement(enemy1.red);
            enemy1.seen = 1;
        } else if(enemy1.seen==1){
            enemyMovement(enemy1.red);
        } else {
            enemy1.red.body.velocity.x = 0;
            enemy1.red.body.velocity.y = 0;
        }

        distance2_from_player = Math.sqrt(Math.abs((player.x - enemy2.red.x))+Math.abs((player.y - enemy2.red.y)));
        if(distance2_from_player<=18){
            enemyMovement(enemy2.red);
            enemy2.seen = 1;
        } else if(enemy2.seen==1){
            enemyMovement(enemy2.red);
        } else {
            enemy2.red.body.velocity.x = 0;
            enemy2.red.body.velocity.y = 0;
        }

    },

    resetPlayer: function(game){
        game.state.start('FailState'); 
    }
}; 


//LEVEL 2 BELOW

Game.Level2 = function(){};

Game.Level2.prototype = {
    create: function(){
        this.stage.backgroundColor = "#000";
        winText = this.game.add.text(this.world.centerX - 88, this.world.centerY - 200, 'Nicely done!!',
                                        {  fontSize: '32px',
                                           fill: '#fff'});
        again_button = this.add.button(this.world.centerX - 95, this.world.centerY + 200, 'buttons',
                                        function(){
                                            this.game.state.start('Level1');
                                        },this,2,1,0);
    }
}

//FAIL STATE BELOW


Game.FailState = function(){};

Game.FailState.prototype = {

    create: function(){
        this.stage.backgroundColor = "#000";
        failText = this.game.add.text(this.world.centerX - 75, this.world.centerY - 200, 'You failed!', 
                                        { fontSize: '32px',
                                          fill: '#fff'});
        retry_button = this.add.button(this.world.centerX - 95, this.world.centerY + 200, 'buttons',
                                        function(){
                                            this.game.state.start('Level1');
                                        },this,2,1,0);
    }
}

function checkOverlap(spriteA,spriteB){

    var boundsA = spriteA.getBounds();
    var boundsB = spriteB.getBounds();
    return Phaser.Rectangle.intersects(boundsA,boundsB);
}


function shootbullet(game) {
    if(game.time.now > shootTime/* && bullets.countDead() > 0*/) {
        shootTime = game.time.now + 200;
        var bullet = bullets.getFirstDead();
        bullet.reset(player.x, player.y);
        game.physics.arcade.moveToPointer(bullet, 2000);
        bullet.body.allowGravity = false;
        bullet.body.bounce.set(0);
    }
}

function enemyMovement(enemy){
    if(Math.abs(enemy.x - player.x) <= 2){
        enemy.x = player.x;
    } else if(enemy.x > player.x){
        enemy.body.velocity.x -= enemySpeed;
    } else if(enemy.x < player.x) {
        enemy.body.velocity.x += enemySpeed;
    } else if(enemy.x == player.x) {
        enemy.body.velocity.x = 0;
    }

    if(Math.abs(enemy.body.velocity.x) > enemySpeed){
        enemy.body.velocity.x = enemySpeed*(enemy.body.velocity.x/Math.abs(enemy.body.velocity.x));
    }

    if(Math.abs(enemy.y - player.y) <= 2){
        enemy.y = player.y;
    } else if(enemy.y > player.y){
        enemy.body.velocity.y -= enemySpeed;
    } else if(enemy.y < player.y) {
        enemy.body.velocity.y += enemySpeed;
    } else if(enemy.y == player.y) {
        enemy.body.velocity.y = 0;
    }

    if(Math.abs(enemy.body.velocity.y) > enemySpeed){
        enemy.body.velocity.y = enemySpeed*(enemy.body.velocity.y/Math.abs(enemy.body.velocity.y));
    }
}




    </script>
</body>
</html>